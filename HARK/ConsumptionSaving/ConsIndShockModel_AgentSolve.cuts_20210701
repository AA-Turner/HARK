        # Bilt.recursive = {'cFunc',  # 'vFunc',  # 'vPfunc', 'vPPfunc',  'vFuncNvrs',
        #                   #             'vFunc.dm', 'vFunc.dm.dm',
        #                   #             'u',  # 'uP', 'uPP', 'uPinv', 'uPinvP', 'uinvP', 'uinv',
        #                   #             'hNrm',
        #                   'mNrmMin', 'MPCmin', 'MPCmax', 'BoroCnstNat', 'CRRA',
        #                   'vAdd'
        #                   }

        # Store recursive stuff in Bilt namespace
        # exclude = {''}  # Allow things that should be excluded
        # for key in (k for k in Bilt.recursive if k not in exclude):  #
        #     if hasattr(self, key):
        #         setattr(Bilt, key, self.__dict__[key])
        #         delattr(self, key)

        # Natural borrowing constraint: Cannot die in debt
        # # Measured after income = tranShk*permShk/permShk received
        # if not hasattr(solution_terminal, 'hNrm'):
        #     _log('warning: hNrm should be set in solution_terminal.')
        #     _log('assuming solution_terminal.hNrm = 0.')
        #     solution_terminal.hNrm = 0.0



        if soln_futr.Bilt.stge_kind['iter_status'] == 'finished':
            breakpoint()
            # Should not have gotten here
            # because core.py tests whether solution_last is 'finished'



        # Organizing principle: folw should have a deepcopy of everything
        # needed to re-solve crnt problem; and everything needed to construct
        # the "fcts" about current stage of the problem, so that the stge could
        # be deepcopied as a standalone object and solved without soln_futr
        # or soln_crnt


        # Create folw
        # for key in (k for k in Bilt.recursive
        #             if k not in
        #             {'solution_next', 'Bilt', 'stge_kind', 'folw'}):
        #     if hasattr(soln_futr.Bilt, key):
        #         setattr(folw, key+'_tp1',
        #                 soln_futr.Bilt.__dict__[key])

        # # Add futr parameters to folw
        # for key in (k for k in soln_futr.Pars.__dict__.keys()):
        #     setattr(folw, key+'_tp1', soln_futr.Pars.__dict__[key])



        # def post_t_E_v_tp1_derivatives_012(xfer_shks_bcst, curr_post_states):
        #     return np.array([post_t_E_v_tp1(xfer_shks_bcst, curr_post_states),
        #                      post_t_E_v_tp1_da_t(xfer_shks_bcst, curr_post_states),
        #                      post_t_E_v_tp1_da_t_da_t(xfer_shks_bcst, curr_post_states)])

        # E_t.v_post_choice = np.squeeze(  # squeezes unused dimensions
        #     calc_expectation_of_array(
        #         IncShkDstn,
        #         post_t_E_v_tp1_derivatives_012,
        #         aNrmGrid)
        # )

        # def post_t_E_v_tp1(xfer_shks_bcst, curr_post_states):
        #     mNrm_tp1 = self.next_ante_states(xfer_shks_bcst, curr_post_states).mNrm
        #     return (Pars.DiscLiv *
        #             xfer_shks_bcst[Pars.permPos] ** (1-CRRA_tp1 - 0) *
        #             futr.vFunc(mNrm_tp1))

        # def post_t_E_v_tp1_da_t(xfer_shks_bcst, curr_post_states):
        #     mNrm_tp1 = self.next_ante_states(xfer_shks_bcst, curr_post_states).mNrm
        #     return (Pars.DiscLiv * Pars.Rfree *
        #             xfer_shks_bcst[Pars.permPos] ** (0-CRRA_tp1 - 0) *
        #             futr.vFunc.dm(mNrm_tp1))

        # def post_t_E_v_tp1_da_t_da_t(xfer_shks_bcst, curr_post_states):
        #     mNrm_tp1 = self.next_ante_states(xfer_shks_bcst, curr_post_states).mNrm
        #     return (Pars.DiscLiv * Pars.Rfree * Pars.Rfree *
        #             xfer_shks_bcst[Pars.permPos] ** (0-CRRA_tp1 - 1) *
        #             futr.vFunc.dm.dm(mNrm_tp1))


#        breakpoint()

    # def calc_EndOfPrdvP(self):
    #     """
    #     Calculate end-of-period marginal value of assets at each point in aNrm.
    #     Does so by taking a weighted sum of next period marginal values across
    #     income shocks (in a preconstructed grid self.soln_crnt.Bilt.mNrmNext).

    #     Parameters
    #     ----------
    #     none

    #     Returns
    #     -------
    #     EndOfPrdvP : np.array
    #         A 1D array of end-of-period marginal value of assets
    #     """

    #     soln_crnt = self.soln_crnt
    #     Bilt = soln_crnt.Bilt
    #     folw = soln_crnt.folw
    #     Pars = soln_crnt.Pars
    #     E_t = soln_crnt.E_t

    #     IncShkDstn = Pars.IncShkDstn
    #     aNrmGrid = Bilt.aNrmGrid

    #     def post_t_v_tp1(xfer_shks_bcst, curr_post_states):
    #         CRRA = folw.vFunc_tp1.CRRA
    #         return (xfer_shks_bcst[Pars.permPos] ** (1-CRRA)
    #                 * folw.vFunc_tp1(self.next_ante_states(xfer_shks_bcst, curr_post_states)))

    #     def post_t_vP_tp1(xfer_shks_bcst, curr_post_states):
    #         CRRA = folw.vFunc_tp1.CRRA
    #         return (xfer_shks_bcst[Pars.permPos] ** (0-CRRA)
    #                 * folw.vFunc_tp1.dm(self.next_ante_states(xfer_shks_bcst, curr_post_states)))

    #     def post_t_v_tp1_dm(xfer_shks_bcst, curr_post_states):
    #         CRRA = folw.vFunc_tp1.CRRA
    #         return (xfer_shks_bcst[Pars.permPos] ** (0-CRRA)
    #                 * folw.vFunc_tp1.dm(self.next_ante_states(xfer_shks_bcst, curr_post_states)))

    #     def post_t_v_tp1_dm_dm(xfer_shks_bcst, curr_post_states):
    #         CRRA = folw.vFunc_tp1.CRRA
    #         return (xfer_shks_bcst[Pars.permPos] ** (0-CRRA - 1.0)
    #                 * folw.vFunc_tp1.dm.dm(self.next_ante_states(xfer_shks_bcst, curr_post_states)))

    #     def post_t_vDers_tp1(xfer_shks_bcst, curr_post_states):
    #         return np.array([post_t_v_tp1(xfer_shks_bcst, curr_post_states),
    #                          post_t_v_tp1_dm(xfer_shks_bcst, curr_post_states),
    #                          post_t_v_tp1_dm_dm(xfer_shks_bcst, curr_post_states)])

    #     EndOfPrdvP = (
    #         Pars.DiscFac * Pars.LivPrb
    #         * Pars.Rfree
    #         * Pars.PermGroFac ** (-Pars.CRRA)
    #         * calc_expectation_of_array(
    #             IncShkDstn,
    #             post_t_vP_tp1,
    #             aNrmGrid
    #         )
    #     )
    #     # Get derivatives 0, 1, and 2 at the same time
    #     E_t.vDers_tp1 = np.squeeze(
    #         Pars.DiscFac * Pars.LivPrb
    #         * Pars.Rfree
    #         * Pars.PermGroFac ** (-Pars.CRRA)
    #         * calc_expectation_of_array(
    #             IncShkDstn,
    #             post_t_vDers_tp1,
    #             aNrmGrid
    #         )
    #     )
    #     breakpoint()

    #     return EndOfPrdvP

#        futr = self.soln_futr
#        Bilt, folw, Pars, E_t = \
#            soln_crnt.Bilt, soln_crnt.folw, soln_crnt.Pars, soln_crnt.E_t
#        CRRA_tp1 = futr.vFunc.CRRA
#         breakpoint()

#         def vPP_tp1(xfer_shks_bcst, curr_post_states):
#             tp1 = self.next_ante_states(xfer_shks_bcst, curr_post_states)
#             mNrmGrid_tp1 = tp1.mNrm
#             return xfer_shks_bcst[Pars.permPos] ** (- CRRA_tp1 - 1.0) \
#                 * folw.vPPfunc_tp1(mNrmGrid_tp1)

#         EndOfPrdvPP = (
#             Pars.DiscFac * Pars.LivPrb
#             * Pars.Rfree
#             * Pars.Rfree
#             * Pars.PermGroFac ** (-CRRA_tp1 - 1.0)
#             * calc_expectation_of_array(
#                 Pars.IncShkDstn,
#                 vPP_tp1,
#                 Bilt.aNrmGrid
#             )
#         )

#         dcda = EndOfPrdvPP / Bilt.uPP(np.array(cNrm_Vec[1:]))
# #        Bilt.uPP(np.array(cNrm_Vec[1:]))


# Contents of the PF solver are inherited by a variety of non-PF models
# so ConsPerfForesightSolver incorporates calcs and info useful for
# models in which perfect foresight does not apply

    def finish_setup_of_default_solution_terminal(self):
        """
        Add to `solution_terminal` characteristics which are not automatically
        created as part of the definition of a generic `solution_terminal.`
        """
        breakpoint()
        # If no solution exists, core.py sets solution_terminal to solution_next
        solution_terminal = self.solution_terminal

        # BoroCnstNat might be nonzero if resuming
        solution_terminal.BoroCnstNat = -solution_terminal.mNrmMin

        # Define BoroCnstArt if not yet defined
        if not hasattr(self.parameters, 'BoroCnstArt'):
            solution_terminal.BoroCnstArt = None
        else:
            solution_terminal.BoroCnstArt = self.parameters.BoroCnstArt

        # partial means this will be replaced by richer augmented soln
        solution_terminal.stge_kind = {'iter_status': 'terminal_partial'}

        # Cubic cFunc is problematic with hard kinks where c'' is undefined
        if hasattr(self, 'CubicBool'):
            solution_terminal.CubicBool = self.parameters['CubicBool']
        else:  # default to false (linear)
            solution_terminal.CubicBool = False

        # General-purpose solution terminal might not have utility or value
        solution_terminal.parameters = self.parameters
        solution_terminal = def_utility(solution_terminal, self.CRRA)
        solution_terminal = def_value_funcs(solution_terminal, self.CRRA)

        return solution_terminal

