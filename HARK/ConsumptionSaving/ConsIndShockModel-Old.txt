    # @staticmethod
    def solver_check_condition(self, name, test, messages, verbose, verbose_messages=None):
        """
        Checks one condition.

        Parameters
        ----------
        name : string
             Name for the condition.

        test : function(self -> boolean)
             A function (of self) which tests the condition

        messages : dict{boolean : string}
            A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false.

        verbose_messages : dict{boolean : string}
            (Optional) A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false under verbose printing.
        """
        self.conditions[name] = test(self)
        set_verbosity_level((4 - verbose) * 10)
        _log.info(messages[self.conditions[name]].format(self))
        if verbose_messages:
            _log.debug(verbose_messages[self.conditions[name]].format(self))

# @staticmethod
def solver_check_condtnnew(self, name, test, messages, verbose, verbose_messages, fact):
    """
        Checks one condition.

        Parameters
        ----------
        name : string
             Name for the condition.

        fact : string
             Name of the factor whose value should be less than 1

        test : function(self -> boolean)
             A function (of self) which tests the condition

        messages : dict{boolean : string}
            A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false.

        verbose_messages : dict{boolean : string}
            (Optional) A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false under verbose printing.
        """

    self.solution_stage.conditions[name] = test(self)
    set_verbosity_level((4 - verbose) * 10)
    self.solution_stage.conditions[fact] = (
        messages[self.solution_stage.conditions[name]] +
        verbose_messages[self.solution_stage.conditions[name]]).format(self.solution_stage)
    print(self.solution_stage.conditions[fact])
    _log.info((
        messages[self.solution_stage.conditions[name]] +
        verbose_messages[self.solution_stage.conditions[name]]).format(self.solution_stage)
    )

    @staticmethod
    def solver_check_condtnnewnew_static(name, test, messages, verbose, verbose_messages, fact, stage):
        """
        Checks one condition.

        Parameters
        ----------
        name : string
             Name for the condition.

        fact : string
             Name of the factor whose value should be less than 1

        test : function(self -> boolean)
             A function (of self) which tests the condition

        messages : dict{boolean : string}
            A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false.

        verbose_messages : dict{boolean : string}
            (Optional) A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false under verbose printing.
        """
        verbose = 3
        stage.conditions[name] = test(stage)
        set_verbosity_level((4 - verbose) * 10)
        stage.conditions[fact] = (
            messages[stage.conditions[name]] +
            verbose_messages[stage.conditions[name]]).format(stage)
        print(stage.conditions[fact])
        _log.info((
            messages[stage.conditions[name]] +
            verbose_messages[stage.conditions[name]]).format(stage)
        )

    # @staticmethod
    def solver_check_AIC_old(self, stage, verbose=None):
        """
        Evaluate and report on the Absolute Impatience Condition
        """
        name = "AIC"
        fact = "APF"

#        def test(agent): return agent.solution_stage.APF < 1
        def test(stage): return stage.APF < 1

        messages = {
            True: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, satisfies the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle'],
            False: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, violates the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Because the APF < 1,  the absolute amount of consumption is expected to fall over time.  \n",
            False: "  Because the APF > 1, the absolute amount of consumption is expected to grow over time.  \n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.solver_check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    # @staticmethod
    def solver_check_AIC_nonstatic(self, stage, verbose=None):
        """
        Evaluate and report on the Absolute Impatience Condition
        """
        name = "AIC"
        fact = "APF"

#        def test(agent): return agent.solution_stage.APF < 1
        def test(stage): return stage.APF < 1

        messages = {
            True: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, satisfies the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle'],
            False: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, violates the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Because the APF < 1,  the absolute amount of consumption is expected to fall over time.  \n",
            False: "  Because the APF > 1, the absolute amount of consumption is expected to grow over time.  \n",
        }
        if hasattr(stage, 'verbose'):
            verbose = stage.verbose if verbose is None else verbose

        stage.solver_check_condtnnewnew_static(name, test, messages, verbose,
                                               verbose_messages, fact, stage)

    @staticmethod
    def core_check_AIC(stage, verbose=None):
        """
        Evaluate and report on the Absolute Impatience Condition
        """
        name = "AIC"
        fact = "APF"

#        def test(agent): return agent.solution_stage.APF < 1
        def test(stage): return stage.APF < 1

        messages = {
            True: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, satisfies the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle'],
            False: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, violates the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Because the APF < 1,  the absolute amount of consumption is expected to fall over time.  \n",
            False: "  Because the APF > 1, the absolute amount of consumption is expected to grow over time.  \n",
        }
        if hasattr(stage, 'verbose'):
            verbose = stage.verbose if verbose is None else verbose

        core_check_condition(name, test, messages, verbose,
                             verbose_messages, fact, stage)

    def solver_check_FVAC_nonstatic(self, stage, verbose=None):
        """
        Evaluate and report on the Finite Value of Autarky Condition
        """
        name = "FVAC"
        fact = "FVAF"

        def test(agent): return stage.FVAF < 1

        messages = {
            True: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, satisfies the Finite Value of Autarky Condition, which requires FVAF < 1: "+stage.FVAC_facts['urlhandle'],
            False: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, violates the Finite Value of Autarky Condition, which requires FVAF: "+stage.FVAC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Therefore, a nondegenerate solution exists if the RIC also holds. ("+stage.FVAC_facts['urlhandle']+")\n",
            False: "  Therefore, a nondegenerate solution exits if the RIC holds.\n",
        }

        if hasattr(stage, 'verbose'):
            verbose = stage.verbose if verbose is None else verbose

        stage.solver_check_condtnnewnew(name, test, messages, verbose,
                                        verbose_messages, fact, stage)

        # @staticmethod
    @staticmethod
    def solver_check_FVAC(stage, verbose=None):
        """
        Evaluate and report on the Finite Value of Autarky Condition
        """
        name = "FVAC"
        fact = "FVAF"

        def test(agent): return stage.FVAF < 1

        messages = {
            True: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, satisfies the Finite Value of Autarky Condition, which requires FVAF < 1: "+stage.FVAC_facts['urlhandle'],
            False: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, violates the Finite Value of Autarky Condition, which requires FVAF: "+stage.FVAC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Therefore, a nondegenerate solution exists if the RIC also holds. ("+stage.FVAC_facts['urlhandle']+")\n",
            False: "  Therefore, a nondegenerate solution exits if the RIC holds.\n",
        }

        if hasattr(stage, 'verbose'):
            verbose = stage.verbose if verbose is None else verbose

        stage.solver_check_condtnnewnew(name, test, messages, verbose,
                                        verbose_messages, fact, stage)

    # @staticmethod
    def solver_check_FVAC_old(self, verbose=None):
        """
        Evaluate and report on the Finite Value of Autarky Condition
        """
        name = "FVAC"
        fact = "FVAF"

        def test(agent): return agent.solution_stage.FVAF < 1

        messages = {
            True: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, satisfies the Finite Value of Autarky Condition, which requires FVAF < 1: "+self.solution_stage.FVAC_facts['urlhandle'],
            False: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, violates the Finite Value of Autarky Condition, which requires FVAF: "+self.solution_stage.FVAC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Therefore, a nondegenerate solution exists if the RIC also holds. ("+self.solution_stage.FVAC_facts['urlhandle']+")\n",
            False: "  Therefore, a nondegenerate solution exits if the RIC holds.\n",
        }

        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    # @staticmethod
    def solver_check_GICRaw(self, verbose=None):
        """
        Evaluate and report on the Growth Impatience Condition
        """
        name = "GICRaw"
        fact = "GPFRaw"

        def test(agent): return agent.solution_stage.GPFRaw < 1

        messages = {
            True: "\nThe Growth Patience Factor for the supplied parameter values, GPF={0.GPFRaw}, satisfies the Growth Impatience Condition (GIC), which requires GPF < 1: "+self.solution_stage.GICRaw_facts['urlhandle'],
            False: "\nThe Growth Patience Factor for the supplied parameter values, GPF={0.GPFRaw}, violates the Growth Impatience Condition (GIC), which requires GPF < 1: "+self.solution_stage.GICRaw_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore,  for a perfect foresight consumer, the ratio of individual wealth to permanent income is expected to fall indefinitely.    \n",
            False: "  Therefore, for a perfect foresight consumer, the ratio of individual wealth to permanent income is expected to rise toward infinity. \n"
        }

        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)
    # @staticmethod
    def solver_check_GICLiv(self, verbose=None):
        name = "GICLiv"
        fact = "GPFLiv"

        def test(agent): return agent.solution_stage.GPFLiv < 1

        messages = {
            True: "\nThe Mortality Adjusted Aggregate Growth Patience Factor for the supplied parameter values, GPFLiv={0.GPFLiv}, satisfies the Mortality Adjusted Aggregate Growth Imatience Condition (GICLiv): "+self.solution_stage.GPFLiv_facts['urlhandle'],
            False: "\nThe Mortality Adjusted Aggregate Growth Patience Factor for the supplied parameter values, GPFLiv={0.GPFLiv}, violates the Mortality Adjusted Aggregate Growth Imatience Condition (GICLiv): "+self.solution_stage.GPFLiv_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore, a target level of the ratio of aggregate market resources to aggregate permanent income exists ("+self.solution_stage.GPFLiv_facts['urlhandle']+")\n",
            False: "  Therefore, a target ratio of aggregate resources to aggregate permanent income may not exist ("+self.solution_stage.GPFLiv_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def solver_check_RIC(self, verbose=None):
        """
        Evaluate and report on the Return Impatience Condition
        """

        name = "RIC"
        fact = "RPF"

        def test(agent): return agent.solution_stage.RPF < 1

        messages = {
            True: "\nThe Return Patience Factor for the supplied parameter values, RPF= {0.RPF}, satisfies the Return Impatience Condition (RIC), which requires RPF < 1: "+self.solution_stage.RPF_facts['urlhandle'],
            False: "\nThe Return Patience Factor for the supplied parameter values, RPF= {0.RPF}, violates the Return Impatience Condition (RIC), which requires RPF < 1: "+self.solution_stage.RPF_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore, the limiting consumption function is not c(m)=0 for all m\n",
            False: "  Therefore, if the FHWC is satisfied, the limiting consumption function is c(m)=0 for all m.\n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def solver_check_FHWC(self, verbose=None):
        """
        Evaluate and report on the Finite Human Wealth Condition
        """
        name = "FHWC"
        fact = "FHWF"

        def test(agent): return agent.solution_stage.FHWF < 1

        messages = {
            True: "\nThe Finite Human Wealth Factor value for the supplied parameter values, FHWF={0.FHWF}, satisfies the Finite Human Wealth Condition (FHWC), which requires FHWF < 1: "+self.solution_stage.FHWC_facts['urlhandle'],
            False: "\nThe Finite Human Wealth Factor value for the supplied parameter values, FHWF={0.FHWF}, violates the Finite Human Wealth Condition (FHWC), which requires FHWF < 1: "+self.solution_stage.FHWC_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore, the limiting consumption function is not c(m)=Infinity ("+self.solution_stage.FHWC_facts['urlhandle']+")\n  Human wealth normalized by permanent income is {0.hNrmNowInf}.\n",
            False: "  Therefore, the limiting consumption function is c(m)=Infinity for all m unless the RIC is also violated.\n  If both FHWC and RIC fail and the consumer faces a liquidity constraint, the limiting consumption function is nondegenerate but has a limiting slope of 0. ("+self.solution_stage.FHWC_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    # @staticmethod
    def solver_check_GICNrm(self, verbose=None):
        """
        Check Individual Growth Patience Factor.
        """
        name = "GICNrm"
        fact = "GPFNrm"

        def test(agent): return agent.solution_stage.GPFNrm <= 1

        messages = {
            True: "\nThe Normalized Growth Patience Factor GPFNrm for the supplied parameter values, GPFNrm={0.GPFNrm}, satisfies the Normalized Growth Impatience Condition (GICNrm), which requires GICNrm < 1: "+self.solution_stage.GPFNrm_facts['urlhandle']+"\n",
            False: "\nThe Normalized Growth Patience Factor GPFNrm for the supplied parameter values, GPFNrm={0.GPFNrm}, violates the Normalized Growth Impatience Condition (GICNrm), which requires GICNrm < 1: "+self.solution_stage.GPFNrm_facts['urlhandle']+"\n",
        }
        verbose_messages = {
            True: " Therefore, a target level of the individual market resources ratio m exists ("+self.solution_stage.GICNrm_facts['urlhandle']+").\n",
            False: " Therefore, a target ratio of individual market resources to individual permanent income does not exist.  ("+self.solution_stage.GICNrm_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
#        self.check_condition(name, test, messages, verbose, verbose_messages)
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    # @staticmethod

    def solver_check_WRIC(self, verbose=None):
        """
        Evaluate and report on the Weak Return Impatience Condition
        [url]/#WRPF modified to incorporate LivPrb
        """
        self.solution_stage.WRPF = (
            (self.solution_stage.UnempPrb ** (1 / self.solution_stage.CRRA))
            * (self.solution_stage.Rfree * self.solution_stage.DiscFac * self.solution_stage.LivStg) ** (1 / self.solution_stage.CRRA)
            / self.solution_stage.Rfree
        )

        self.solution_stage.WRIC = self.solution_stage.WRPF < 1
        name = "WRIC"
        fact = "WRPF"

        def test(agent): return agent.solution_stage.WRPF <= 1

        WRIC_facts = {'about': 'Weak Return Impatience Condition'}
        WRIC_facts.update({'latexexpr': r'\WRIC'})
        WRIC_facts.update({'urlhandle': self.solution_stage.urlroot+'WRIC'})
        WRIC_facts.update({'py___code': 'test: agent.WRPF < 1'})
        self.solution_stage.WRIC_facts = WRIC_facts

        WRPF_facts = {'about': 'Growth Patience Factor'}
        WRPF_facts.update({'latexexpr': r'\WRPF'})
        WRPF_facts.update({'_unicode_': r'℘ RPF'})
        WRPF_facts.update({'urlhandle': self.solution_stage.urlroot+'WRPF'})
        WRPF_facts.update({'py___code': r'UnempPrb * RPF'})

        messages = {
            True: "\nThe Weak Return Patience Factor value for the supplied parameter values, WRPF={0.WRPF}, satisfies the Weak Return Impatience Condition, which requires WRIF < 1: "+self.solution_stage.WRIC_facts['urlhandle'],
            False: "\nThe Weak Return Patience Factor value for the supplied parameter values, WRPF={0.WRPF}, violates the Weak Return Impatience Condition, which requires WRIF < 1: "+self.solution_stage.WRIC_facts['urlhandle'],
        }

        verbose_messages = {
            True: "  Therefore, a nondegenerate solution exists if the FVAC is also satisfied. ("+self.solution_stage.WRIC_facts['urlhandle']+")\n",
            False: "  Therefore, a nondegenerate solution is not available ("+self.solution_stage.WRIC_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
#        self.check_condition(name, test, messages, verbose, verbose_messages)
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

        self.solution_stage.WRPF_facts = WRPF_facts

    # @staticmethod
    def solver_check_condtnsnew(self, verbose=None):
        """
        This method checks whether the instance's type satisfies the
        Absolute Impatience Condition (AIC),
        the Return Impatience Condition (RIC),
        the Finite Human Wealth Condition (FHWC), the perfect foresight
        model's Growth Impatience Condition (GICRaw) and
        Perfect Foresight Finite Value of Autarky Condition (FVACPF). Depending on the configuration of parameter values, some
        combination of these conditions must be satisfied in order for the problem to have
        a nondegenerate solution_stage. To check which conditions are required, in the verbose mode
        a reference to the relevant theoretical literature is made.

        Parameters
        ----------
        verbose : boolean
            Specifies different levels of verbosity of feedback. When False, it only reports whether the
            instance's type fails to satisfy a particular condition. When True, it reports all results, i.e.
            the factor values for all conditions.

        Returns
        -------
        None
        """
        self.solution_stage.conditions = {}

        self.solution_stage.violated = False

        # This method only checks for the conditions for infinite horizon models
        # with a 1 period cycle. If these conditions are not met, we exit early.
        if self.cycles != 0 or self.T_cycle > 1:
            return

        verbose = self.verbose if verbose is None else verbose
        self.check_AIC(verbose)
        self.check_FHWC(verbose)
        self.check_RIC(verbose)
        self.check_GICRaw(verbose)
        self.check_GICLiv(verbose)
        self.check_FVAC(verbose)

        if hasattr(self, "BoroCnstArt") and self.solution_stage.BoroCnstArt is not None:
            self.solution_stage.violated = not self.solution_stage.conditions["RIC"]
        else:
            self.solution_stage.violated = not self.solution_stage.conditions[
                "RIC"] or not self.solution_stage.conditions["FHWC"]


    def check_condition(self, name, test, messages, verbose, verbose_messages=None):
        """
        Checks one condition.

        Parameters
        ----------
        name : string
             Name for the condition.

        test : function(self -> boolean)
             A function (of self) which tests the condition

        messages : dict{boolean : string}
            A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false.

        verbose_messages : dict{boolean : string}
            (Optional) A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false under verbose printing.
        """
        self.conditions[name] = test(self)
        set_verbosity_level((4 - verbose) * 10)
        _log.info(messages[self.conditions[name]].format(self))
        if verbose_messages:
            _log.debug(verbose_messages[self.conditions[name]].format(self))

    def check_condtnnew(self, name, test, messages, verbose, verbose_messages, fact):
        """
        Checks one condition.

        Parameters
        ----------
        name : string
             Name for the condition.

        fact : string
             Name of the factor whose value should be less than 1

        test : function(self -> boolean)
             A function (of self) which tests the condition

        messages : dict{boolean : string}
            A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false.

        verbose_messages : dict{boolean : string}
            (Optional) A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false under verbose printing.
        """
        self.solution_stage.conditions[name] = test(self)
        set_verbosity_level((4 - verbose) * 10)
        self.solution_stage.conditions[fact] = (
            messages[self.solution_stage.conditions[name]] +
            verbose_messages[self.solution_stage.conditions[name]]).format(self.solution_stage)
        print(self.solution_stage.conditions[fact])
        _log.info((
            messages[self.solution_stage.conditions[name]] +
            verbose_messages[self.solution_stage.conditions[name]]).format(self.solution_stage)
        )

    def check_AIC(self, verbose=None):
        """
        Evaluate and report on the Absolute Impatience Condition
        """
        name = "AIC"
        fact = "APF"

        def test(agent): return agent.solution_stage.APF < 1

        messages = {
            True: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, satisfies the Absolute Impatience Condition (AIC), which requires APF < 1: "+self.solution_stage.AIC_facts['urlhandle'],
            False: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, violates the Absolute Impatience Condition (AIC), which requires APF < 1: "+self.solution_stage.AIC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Because the APF < 1,  the absolute amount of consumption is expected to fall over time.  \n",
            False: "  Because the APF > 1, the absolute amount of consumption is expected to grow over time.  \n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_FVAC(self, verbose=None):
        """
        Evaluate and report on the Finite Value of Autarky Condition
        """
        name = "FVAC"
        fact = "FVAF"

        def test(agent): return agent.solution_stage.FVAF < 1

        messages = {
            True: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, satisfies the Finite Value of Autarky Condition, which requires FVAF < 1: "+self.solution_stage.FVAC_facts['urlhandle'],
            False: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, violates the Finite Value of Autarky Condition, which requires FVAF: "+self.solution_stage.FVAC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Therefore, a nondegenerate solution exists if the RIC also holds. ("+self.solution_stage.FVAC_facts['urlhandle']+")\n",
            False: "  Therefore, a nondegenerate solution exits if the RIC holds.\n",
        }

        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_GICRaw(self, verbose=None):
        """
        Evaluate and report on the Growth Impatience Condition
        """
        name = "GICRaw"
        fact = "GPFRaw"

        def test(agent): return agent.solution_stage.GPFRaw < 1

        messages = {
            True: "\nThe Growth Patience Factor for the supplied parameter values, GPF={0.GPFRaw}, satisfies the Growth Impatience Condition (GIC), which requires GPF < 1: "+self.solution_stage.GICRaw_facts['urlhandle'],
            False: "\nThe Growth Patience Factor for the supplied parameter values, GPF={0.GPFRaw}, violates the Growth Impatience Condition (GIC), which requires GPF < 1: "+self.solution_stage.GICRaw_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore,  for a perfect foresight consumer, the ratio of individual wealth to permanent income is expected to fall indefinitely.    \n",
            False: "  Therefore, for a perfect foresight consumer, the ratio of individual wealth to permanent income is expected to rise toward infinity. \n"
        }

        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_GICLiv(self, verbose=None):
        name = "GICLiv"
        fact = "GPFLiv"

        def test(agent): return agent.solution_stage.GPFLiv < 1

        messages = {
            True: "\nThe Mortality Adjusted Aggregate Growth Patience Factor for the supplied parameter values, GPFLiv={0.GPFLiv}, satisfies the Mortality Adjusted Aggregate Growth Imatience Condition (GICLiv): "+self.solution_stage.GPFLiv_facts['urlhandle'],
            False: "\nThe Mortality Adjusted Aggregate Growth Patience Factor for the supplied parameter values, GPFLiv={0.GPFLiv}, violates the Mortality Adjusted Aggregate Growth Imatience Condition (GICLiv): "+self.solution_stage.GPFLiv_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore, a target level of the ratio of aggregate market resources to aggregate permanent income exists ("+self.solution_stage.GPFLiv_facts['urlhandle']+")\n",
            False: "  Therefore, a target ratio of aggregate resources to aggregate permanent income may not exist ("+self.solution_stage.GPFLiv_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_RIC(self, verbose=None):
        """
        Evaluate and report on the Return Impatience Condition
        """

        name = "RIC"
        fact = "RPF"

        def test(agent): return agent.solution_stage.RPF < 1

        messages = {
            True: "\nThe Return Patience Factor for the supplied parameter values, RPF= {0.RPF}, satisfies the Return Impatience Condition (RIC), which requires RPF < 1: "+self.solution_stage.RPF_facts['urlhandle'],
            False: "\nThe Return Patience Factor for the supplied parameter values, RPF= {0.RPF}, violates the Return Impatience Condition (RIC), which requires RPF < 1: "+self.solution_stage.RPF_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore, the limiting consumption function is not c(m)=0 for all m\n",
            False: "  Therefore, if the FHWC is satisfied, the limiting consumption function is c(m)=0 for all m.\n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_FHWC(self, verbose=None):
        """
        Evaluate and report on the Finite Human Wealth Condition
        """
        name = "FHWC"
        fact = "FHWF"

        def test(agent): return agent.solution_stage.FHWF < 1

        messages = {
            True: "\nThe Finite Human Wealth Factor value for the supplied parameter values, FHWF={0.FHWF}, satisfies the Finite Human Wealth Condition (FHWC), which requires FHWF < 1: "+self.solution_stage.FHWC_facts['urlhandle'],
            False: "\nThe Finite Human Wealth Factor value for the supplied parameter values, FHWF={0.FHWF}, violates the Finite Human Wealth Condition (FHWC), which requires FHWF < 1: "+self.solution_stage.FHWC_facts['urlhandle'],
        }
        verbose_messages = {
            True: "  Therefore, the limiting consumption function is not c(m)=Infinity ("+self.solution_stage.FHWC_facts['urlhandle']+")\n  Human wealth normalized by permanent income is {0.hNrmNowInf}.\n",
            False: "  Therefore, the limiting consumption function is c(m)=Infinity for all m unless the RIC is also violated.\n  If both FHWC and RIC fail and the consumer faces a liquidity constraint, the limiting consumption function is nondegenerate but has a limiting slope of 0. ("+self.solution_stage.FHWC_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_condtnsnew(self, verbose=None):
        """
        This method checks whether the instance's type satisfies the
        Absolute Impatience Condition (AIC),
        the Return Impatience Condition (RIC),
        the Finite Human Wealth Condition (FHWC), the perfect foresight
        model's Growth Impatience Condition (GICRaw) and
        Perfect Foresight Finite Value of Autarky Condition (FVACPF). Depending on the configuration of parameter values, some
        combination of these conditions must be satisfied in order for the problem to have
        a nondegenerate solution_stage. To check which conditions are required, in the verbose mode
        a reference to the relevant theoretical literature is made.

        Parameters
        ----------
        verbose : boolean
            Specifies different levels of verbosity of feedback. When False, it only reports whether the
            instance's type fails to satisfy a particular condition. When True, it reports all results, i.e.
            the factor values for all conditions.

        Returns
        -------
        None
        """
        self.solution_stage.conditions = {}

        self.solution_stage.violated = False

        # This method only checks for the conditions for infinite horizon models
        # with a 1 period cycle. If these conditions are not met, we exit early.
        if self.cycles != 0 or self.T_cycle > 1:
            return

        verbose = self.verbose if verbose is None else verbose
        self.check_AIC(verbose)
        self.check_FHWC(verbose)
        self.check_RIC(verbose)
        self.check_GICRaw(verbose)
        self.check_GICLiv(verbose)
        self.check_FVAC(verbose)

        if hasattr(self, "BoroCnstArt") and self.solution_stage.BoroCnstArt is not None:
            self.solution_stage.violated = not self.solution_stage.conditions["RIC"]
        else:
            self.solution_stage.violated = not self.solution_stage.conditions[
                "RIC"] or not self.solution_stage.conditions["FHWC"]



        def add_method(obj, func):
            setattr(obj, func.__name, partial, func, obj)

        add_method(self.solution_stage,
                   self.solver_check_condtnnewnew_static)
        add_method(self.solution_stage,
                   self.solver_check_AIC)
        self.solution_stage.solver_check_AIC()

        self.solution_stage.solver_check_condtnnewnew_static = \
            self.solver_check_condtnnewnew_static.__get__(self.solution_stage)
        self.solution_stage.solver_check_AIC = \
            self.solver_check_AIC.__get__(self.solution_stage)
        self.solution_stage.solver_check_AIC(
            self.solution_stage)
        import types
        self.solution_stage.solver_check_condtnnewnew = \
            types.MethodType(self.solver_check_condtnnewnew, self.solution_stage)

        self.solution_stage.solver_check_FVAC_nonstatic = \
            types.MethodType(self.solver_check_FVAC_nonstatic, self.solution_stage)
        self.solution_stage.solver_check_FVAC_nonstatic(
            self.solution_stage)
        breakpoint()
        self.solution_stage.solver_check_AIC = self.solver_check_AIC
        self.solution_stage.solver_check_FVAC = self.solver_check_FVAC
        self.solution_stage.solver_check_condtnnewnew = self.solver_check_condtnnewnew

#        stage = deepcopy(self.solution_stage)
        self.solution_stage.solver_check_AIC(self.solution_stage)
        self.core_check_AIC(self.solution_stage, verbose=3)
        self.solution_stage.solver_check_FVAC(self.solution_stage)


    def check_GICNrm(self, verbose=None):
        """
        Check Individual Growth Patience Factor.
        """
        name = "GICNrm"
        fact = "GPFNrm"

        def test(agent): return agent.solution_stage.GPFNrm <= 1

        messages = {
            True: "\nThe Normalized Growth Patience Factor GPFNrm for the supplied parameter values, GPFNrm={0.GPFNrm}, satisfies the Normalized Growth Impatience Condition (GICNrm), which requires GICNrm < 1: "+self.solution_stage.GPFNrm_facts['urlhandle']+"\n",
            False: "\nThe Normalized Growth Patience Factor GPFNrm for the supplied parameter values, GPFNrm={0.GPFNrm}, violates the Normalized Growth Impatience Condition (GICNrm), which requires GICNrm < 1: "+self.solution_stage.GPFNrm_facts['urlhandle']+"\n",
        }
        verbose_messages = {
            True: " Therefore, a target level of the individual market resources ratio m exists ("+self.solution_stage.GICNrm_facts['urlhandle']+").\n",
            False: " Therefore, a target ratio of individual market resources to individual permanent income does not exist.  ("+self.solution_stage.GICNrm_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
#        self.check_condition(name, test, messages, verbose, verbose_messages)
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_WRIC(self, verbose=None):
        """
        Evaluate and report on the Weak Return Impatience Condition
        [url]/#WRPF modified to incorporate LivPrb
        """
        self.solution_stage.WRPF = (
            (self.solution_stage.UnempPrb ** (1 / self.solution_stage.CRRA))
            * (self.solution_stage.Rfree * self.solution_stage.DiscFac * self.solution_stage.LivStg) ** (1 / self.solution_stage.CRRA)
            / self.solution_stage.Rfree
        )

        self.solution_stage.WRIC = self.solution_stage.WRPF < 1
        name = "WRIC"
        fact = "WRPF"

        def test(agent): return agent.solution_stage.WRPF <= 1

        WRIC_facts = {'about': 'Weak Return Impatience Condition'}
        WRIC_facts.update({'latexexpr': r'\WRIC'})
        WRIC_facts.update({'urlhandle': self.solution_stage.urlroot+'WRIC'})
        WRIC_facts.update({'py___code': 'test: agent.WRPF < 1'})
        self.solution_stage.WRIC_facts = WRIC_facts

        WRPF_facts = {'about': 'Growth Patience Factor'}
        WRPF_facts.update({'latexexpr': r'\WRPF'})
        WRPF_facts.update({'_unicode_': r'℘ RPF'})
        WRPF_facts.update({'urlhandle': self.solution_stage.urlroot+'WRPF'})
        WRPF_facts.update({'py___code': r'UnempPrb * RPF'})

        messages = {
            True: "\nThe Weak Return Patience Factor value for the supplied parameter values, WRPF={0.WRPF}, satisfies the Weak Return Impatience Condition, which requires WRIF < 1: "+self.solution_stage.WRIC_facts['urlhandle'],
            False: "\nThe Weak Return Patience Factor value for the supplied parameter values, WRPF={0.WRPF}, violates the Weak Return Impatience Condition, which requires WRIF < 1: "+self.solution_stage.WRIC_facts['urlhandle'],
        }

        verbose_messages = {
            True: "  Therefore, a nondegenerate solution_stage exists if the FVAC is also satisfied. ("+self.solution_stage.WRIC_facts['urlhandle']+")\n",
            False: "  Therefore, a nondegenerate solution_stage is not available ("+self.solution_stage.WRIC_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
#        self.check_condition(name, test, messages, verbose, verbose_messages)
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

        self.solution_stage.WRPF_facts = WRPF_facts

    def check_FVAC(self, verbose=None):
        """
        Evaluate and report on the Finite Value of Autarky Condition
        """
        name = "FVAC"
        fact = "FVAF"

        def test(agent): return agent.solution_stage.FVAF < 1

        messages = {
            True: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, satisfies the Finite Value of Autarky Condition, which requires FVAF < 1: "+self.solution_stage.FVAC_facts['urlhandle'],
            False: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, violates the Finite Value of Autarky Condition, which requires FVAF < 1: "+self.solution_stage.FVAC_facts['urlhandle']
        }

        verbose_messages = {
            # ; see {0.url}/#Conditions-Under-Which-the-Problem-Defines-a-Contraction-Mapping\n",
            True: "  Therefore, a nondegenerate solution_stage exists if the WRIC also holds. ("+self.solution_stage.FVAC_facts['urlhandle']+")\n",
            # (see {0.url}/#Conditions-Under-Which-the-Problem-Defines-a-Contraction-Mapping\n",
            False: "  Therefore, a nondegenerate solution_stage is not available ("+self.solution_stage.FVAC_facts['urlhandle']+")\n",
        }
        verbose = self.verbose if verbose is None else verbose
#        self.check_condition(name, test, messages, verbose, verbose_messages)
        self.check_condtnnew(name, test, messages, verbose, verbose_messages, fact)

    def check_condtnsnew(self, verbose=None):
        """
        Checks whether the type satisfies the Absolute Impatience Condition (AIC), Weak Return
        Impatience Condition (WRIC), Finite Human Wealth Condition (FHWC) and Finite Value of
        Autarky Condition (FVAC).  When combinations of these conditions are satisfied, the
        solution_stage to the problem exhibits different characteristics.  (For an exposition of the
        conditions, see https://econ-ark.github.io/BufferStockTheory/)

        Parameters
        ----------
        verbose : boolean
            Specifies different levels of verbosity of feedback. When False, it only reports whether the
            instance's type fails to satisfy a particular condition. When True, it reports all results, i.e.
            the factor values for all conditions.

        Returns
        -------
        None
        """
        self.conditions = {}

        self.violated = False

        if self.cycles != 0 or self.T_cycle > 1:
            if self.verbose == 3:
                _log.warning("The conditions apply only to infinite horizon models")
            return

        self.check_AIC(verbose)
        self.check_RIC(verbose)
        self.check_FHWC(verbose)
        self.check_GICNrm(verbose)
        self.check_GICRaw(verbose)
        self.check_GICLiv(verbose)
        self.check_WRIC(verbose)
        self.check_FVAC(verbose)

        self.violated = not self.solution_stage.conditions["WRIC"] or not self.solution_stage.conditions["FVAC"]

        if self.violated:
            _log.warning('Under the provided parameter values, the solution_stage is degenerate')
            _log.warning(
                '\n[!] For more information on the conditions, see Tables 3 and 4 in "Theoretical Foundations of Buffer Stock Saving" at '
                + self.url_ref
                + "/#Factors-Defined-And-Compared"
            )

        _log.warning("APF            = %2.6f " %
                     (self.solution_stage.APF) + '  ' + str(self.solution_stage.APF_facts['urlhandle']))
        _log.warning("RPF            = %2.6f " %
                     (self.solution_stage.RPF) + '  ' + str(self.solution_stage.RPF_facts['urlhandle']))
        _log.warning("FHWF           = %2.6f " %
                     (self.solution_stage.FHWF) + '  ' + str(self.solution_stage.FHWF_facts['urlhandle']))
        _log.warning("GPFNrm         = %2.6f " % (
            self.solution_stage.GPFNrm) + '  ' + str(self.solution_stage.GPFNrm_facts['urlhandle']))
        _log.warning("GPFRaw         = %2.6f " % (
            self.solution_stage.GPFRaw) + '  ' + str(self.solution_stage.GPFRaw_facts['urlhandle']))
        _log.warning("GPFLiv         = %2.6f " % (
            self.solution_stage.GPFLiv) + '  ' + str(self.solution_stage.GPFLiv_facts['urlhandle']))
        _log.warning("FVAF           = %2.6f " %
                     (self.solution_stage.FVAF) + '  ' + str(self.solution_stage.FVAF_facts['urlhandle']))
        _log.warning("WRPF           = %2.6f " %
                     (self.solution_stage.WRPF) + '  ' + str(self.solution_stage.WRPF_facts['urlhandle']))
        _log.warning("DiscGPFNrmCusp = %2.6f " % (self.solution_stage.DiscGPFNrmCusp) + '  code:' +
                     self.solution_stage.DiscGPFNrmCusp_facts['py___code'])
        _log.warning("DiscGPFRawCusp = %2.6f " % (self.solution_stage.DiscGPFRawCusp) + '  code:' +
                     self.solution_stage.DiscGPFRawCusp_facts['py___code'])
        _log.warning("DiscGPFLivCusp = %2.6f " % (self.solution_stage.DiscGPFLivCusp) + '  code:' +
                     self.solution_stage.DiscGPFLivCusp_facts['py___code'])


    def solver_check_condtnnew_20210404(self, name, test, messages, verbose, verbose_messages, fact, stage):
        """
        Checks one condition.

        Parameters
        ----------
        name : string
             Name for the condition.

        fact : string
             Name of the factor whose value should be less than 1

        test : function(self -> boolean)
             A function (of self) which tests the condition

        messages : dict{boolean : string}
            A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false.

        verbose_messages : dict{boolean : string}
            (Optional) A dictiomary with boolean keys containing values
            for messages to print if the condition is
            true or false under verbose printing.
        """

        stage.conditions[name] = test(stage)
        set_verbosity_level((4 - verbose) * 10)
        stage.conditions[fact] = (
            messages[stage.conditions[name]] +
            verbose_messages[stage.conditions[name]]).format(stage)
        print(stage.conditions[fact])
        _log.info((
            messages[stage.conditions[name]] +
            verbose_messages[stage.conditions[name]]).format(stage)
        )




    @staticmethod
    def solver_check_AIC(stage, verbose=None):
        """
        Evaluate and report on the Absolute Impatience Condition
        """
        name = "AIC"
        fact = "APF"

#        def test(agent): return agent.solution_stage.APF < 1
        def test(stage): return stage.APF < 1

        messages = {
            True: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, satisfies the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle'],
            False: "\nThe Absolute Patience Factor for the supplied parameter values, APF={0.APF}, violates the Absolute Impatience Condition (AIC), which requires APF < 1: "+stage.AIC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Because the APF < 1,  the absolute amount of consumption is expected to fall over time.  \n",
            False: "  Because the APF > 1, the absolute amount of consumption is expected to grow over time.  \n",
        }
        if hasattr(stage, 'verbose'):
            verbose = stage.verbose if verbose is None else verbose

        core_check_condition(name, test, messages, verbose,
                             verbose_messages, fact, stage)


    def solver_check_FVAC_20210404(stage, verbose=None):
        """
        Evaluate and report on the Finite Value of Autarky Condition
        """
        name = "FVAC"
        fact = "FVAF"

        def test(agent): return stage.FVAF < 1

        messages = {
            True: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, satisfies the Finite Value of Autarky Condition, which requires FVAF < 1: "+stage.FVAC_facts['urlhandle'],
            False: "\nThe Finite Value of Autarky Factor for the supplied parameter values, FVAF={0.FVAF}, violates the Finite Value of Autarky Condition, which requires FVAF: "+stage.FVAC_facts['urlhandle']
        }
        verbose_messages = {
            True: "  Therefore, a nondegenerate solution exists if the RIC also holds. ("+stage.FVAC_facts['urlhandle']+")\n",
            False: "  Therefore, a nondegenerate solution exits if the RIC holds.\n",
        }

        if hasattr(stage, 'verbose'):
            verbose = stage.verbose if verbose is None else verbose



# class ConsumerSolutionWithEx(ConsumerSolution):
#     """
#     ConsumerSolution enhanced with functions to calculate various objects that
#     are interesting or useful for understanding the consumer's problem.

#     Parameters
#     ----------
#     cFunc : function
#         The consumption function for this period, defined over market
#         resources: c = cFunc(m).
#     vFunc : function
#         The beginning-of-period value function for this period, defined over
#         market resources: v = vFunc(m).
#     vPfunc : function
#         The beginning-of-period marginal value function for this period,
#         defined over market resources: vP = vPfunc(m).
#     vPPfunc : function
#         The beginning-of-period marginal marginal value function for this
#         period, defined over market resources: vPP = vPPfunc(m).
#     mNrmMin : float
#         The minimum allowable market resources for this period; the consump-
#         tion and other functions are undefined for m < mNrmMin.
#     hNrmNow : float
#         Human wealth after receiving income this period: PDV of all future
#         income, ignoring mortality.
#     MPCminNow : float
#         Infimum of the marginal propensity to consume this period.
#         MPC --> MPCminNow as m --> infinity.
#     MPCmaxNow : float
#         Supremum of the marginal propensity to consume this period.
#         MPC --> MPCmaxNow as m --> mNrmMin.
#     """

    # def mNrmTrg_finder(self):
    #     """
    #     Finds value of (normalized) market resources mNrm at which individual consumer
    #     expects m not to change.

    #     This will exist if the GICNrm holds.

    #     https://econ-ark.github.io/BufferStockTheory#UniqueStablePoints

    #     Parameters
    #     ----------
    #     solution : ConsumerSolution
    #         Solution to this period's problem, which must have attribute cFunc.
    #     Returns
    #     -------
    #         The target value mNrmTrg.
    #     """

    #     # Minimum market resources plus next income is okay starting guess
    #     # Better would be to presere the last value (if it exists)
    #     # and use that as a starting point

    #     m_init_guess = self.mNrmMin + self.Ex_IncNextNrm
    #     try:  # Find value where argument is zero
    #         self.mNrmTrg = newton(
    #             self.Ex_m_tp1_minus_m_t,
    #             m_init_guess)
    #     except:
    #         self.mNrmTrg = None

    #     return self.mNrmTrg

